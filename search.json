[
  {
    "objectID": "currentStatus/dmaToDac.html",
    "href": "currentStatus/dmaToDac.html",
    "title": "Outputting Audio",
    "section": "",
    "text": "To read out the digital audio onto speakers, we will use the onboard MCU DAC with Direct Memory Access (DMA). The DAC has two channels, which we will use to output the two audio signals. We plan to use DMA with a circular buffer to read out the I2S audio data, as this will allow us more flexibility with the timing within the system. Thus, we need to ensure that the input and output rates are equivalent."
  },
  {
    "objectID": "currentStatus/mcuDesign.html",
    "href": "currentStatus/mcuDesign.html",
    "title": "MCU Design",
    "section": "",
    "text": "The microcontroller held two roles in our system. First, it would output the audio, converting it from digital to analog. Second, it would pass the lowpass and highpass filter cutoff values to the FPGA. While we ultimately did not succeed in implementing digital filtering on the FPGA, the MCU fulfilled its role in sending over the filter cutoff values."
  },
  {
    "objectID": "currentStatus/mcuDesign.html#outputting-audio",
    "href": "currentStatus/mcuDesign.html#outputting-audio",
    "title": "MCU Design",
    "section": "Outputting Audio",
    "text": "Outputting Audio\nThe MCU takes in 8-bit mono audio data from the FPGA using SPI and stores the value in memory. As the onboard Digital-to-Analog Converter (DAC) can only read positive voltages, we converted our signed values to unsigned values and stored the value into a variable named leftAudio. We then used the onboard MCU DAC with Direct Memory Access (DMA) to convert the digital data to an analog signal. The DMA transfer was initiated by a reload event of TIM7 and would move the value stored in leftAudio into the output register of the DAC. By setting DMA to circular mode, it would continuously read from the leftAudio variable, as it was updated by SPI. Therefore, it was imperative to ensure that the clock speed of both the FPGA and MCU would be fast enough as to not warp the audio.\nTo make our code scalable to stereo audio, we used both DAC1 and DAC2 and their corresponding DMA channels to output the audio to two separate pins, PA4 and PA5. This also allowed us the flexibility to manipulate the output analog audio with circuits to apply lowpass and highpass filters.\nWhen we opted to use the onboard MCU DAC and SPI, we were hesitant of bringing down the audio data from 24-bit to 8-bit resolution, which would mean lowering the discrete levels of audio from 16,777,215 to 256. While this would not impact the maximum amplitude, it would reduce the precision and dynamic range. We decided the best way to test this would be by doing – so we implemented the DAC and DMA with 8-bit resolution and tried to see if we could spot an audible difference. When testing with sine waves at different frequencies as well as our personal playlists, we could not tell the difference between the original audio versus the MCU output audio. Therefore, we decided that 8-bit audio would be sufficient."
  },
  {
    "objectID": "currentStatus/mcuDesign.html#filter-cutoff-values",
    "href": "currentStatus/mcuDesign.html#filter-cutoff-values",
    "title": "MCU Design",
    "section": "Filter Cutoff Values",
    "text": "Filter Cutoff Values\nThe microcontroller also takes in an analog signal from the potentiometer and then converts that value into digital signals using the on-board ADC. The clock speed at which is running at a clock speed of 12 MHz. The MCU then sends the signal to the FPGA using SPI communication."
  },
  {
    "objectID": "currentStatus/fpgaDesign.html",
    "href": "currentStatus/fpgaDesign.html",
    "title": "FPGA Design",
    "section": "",
    "text": "The main design features of the FPGA is to receive digital audio from the external ADC, apply digital filters to the audio based on user inputs passed from the MCU, and then send the filtered audio to the MCU. The FPGA receives audio from the ADC using an I2S Communication Protocol, and then implements the onboard multiply-accumulator block (MAC) to the data and then outputs it. Due to time constraints, we were not able to implement digital filtering on our hardware, but we were able to get the desired behavior in ModelSim using the MAC."
  },
  {
    "objectID": "currentStatus/fpgaDesign.html#fpga-design-overview",
    "href": "currentStatus/fpgaDesign.html#fpga-design-overview",
    "title": "FPGA Design",
    "section": "",
    "text": "The main design features of the FPGA is to receive digital audio from the external ADC, apply digital filters to the audio based on user inputs passed from the MCU, and then send the filtered audio to the MCU. The FPGA receives audio from the ADC using an I2S Communication Protocol, and then implements the onboard multiply-accumulator block (MAC) to the data and then outputs it. Due to time constraints, we were not able to implement digital filtering on our hardware, but we were able to get the desired behavior in ModelSim using the MAC."
  },
  {
    "objectID": "currentStatus/fpgaDesign.html#communicating-eq-values-to-fpga",
    "href": "currentStatus/fpgaDesign.html#communicating-eq-values-to-fpga",
    "title": "FPGA Design",
    "section": "Communicating EQ Values to FPGA",
    "text": "Communicating EQ Values to FPGA\nThe EQ values are determined by potentiometer voltage dividers being routed into the MCU. The MCU ADC converts these analog values into 8-bit values between 0 to 256, which will ultimately be used to determine the passband frequencies for the low and high pass filters.\nAfter the MCU interprets these voltages into 8-bit values, it passes these values using SPI to the FPGA. Below is an example of a working SPI interaction. When the potentiometer is set to approximately 79.\n\n\n\nEQ Values Printed Out Debug Terminal\n\n\n\n\n\nLogic Analyzer SPI"
  },
  {
    "objectID": "currentStatus/fpgaDesign.html#generating-coefficients",
    "href": "currentStatus/fpgaDesign.html#generating-coefficients",
    "title": "FPGA Design",
    "section": "Generating Coefficients",
    "text": "Generating Coefficients\nWe opted to pass in FIR coefficients generated in MatLab so that we could utilize the DSP toolbox and easily visualize and adjust the filter and taps.\nIn order to use these coefficients in the FPGA, we wanted to convert the values from floating point to integer, which requires scaling the coefficients by a value of g. The floating point and integer coefficients are shown below, where if we scale the signal we see that the shape of the plots are the same. Thus, when plotting the output signal, it is critical to scale the signal by dividing by g.\nThe below figures are for a lowpass filter with 128 taps and a pass band ending at 1250 hZ.\n\n\n\nInteger coefficients are scaled up from floating point coefficients\n\n\n\n\n\nFloating point and integer coefficients share the same shape\n\n\n\n\n\nFIR Filter as defined by coefficients\n\n\nWe then confirmed the design of these filters by creating a signal with multiple frequency components and applying our filter and gain scaling. To do this, we copied out verilog logic, allowing us to confirm that our logic acted as expected.\n\n\n\nOriginal signal with multiple frequency components\n\n\n\n\n\nOutput and original signal"
  },
  {
    "objectID": "currentStatus/fpgaDesign.html#passing-in-the-coefficients",
    "href": "currentStatus/fpgaDesign.html#passing-in-the-coefficients",
    "title": "FPGA Design",
    "section": "Passing in the Coefficients",
    "text": "Passing in the Coefficients\nIn order to retrieve the proper coefficients, the filter number was inputted based on a digital input from the MCU. Thus, based on what the user selects, the code will then retrieve the set of 128 coefficients that correspond to the filter value that they requested. This was done by saving a .txt file with all 2048 coefficients (128 coefficients per filter, 16 different filter options), and then storing the desired coefficients synchronously in BRAM. An FSM is used to retrieve all 128 coefficients on each clock cycle that will then be used to digitally filter the signal."
  },
  {
    "objectID": "currentStatus/fpgaDesign.html#modeling-dsp",
    "href": "currentStatus/fpgaDesign.html#modeling-dsp",
    "title": "FPGA Design",
    "section": "Modeling DSP",
    "text": "Modeling DSP\nThe modules created in ModelSim contained code from Lab 7 to retrieve the different taps read from a .txt file stored in memory based on desired filter values received from the MCU via SPI. The FPGA would also create a signal window that would contain the past 10 samples of digital audio from the ADC to be used for FIR filtering. This signal window and the retrieved taps would then be inputted to the MAC to be multiplied and summed up together. The MAC was configured to take in 2 signed 16-bit inputs, and then output a 33-bit result for 10 tap coefficients. It also received the system clock as input generated from the high speed oscillator at 12 MHz. The output data from the MAC was then scaled back down by being divided by the filter’s gains, and then concatenated to 8 bits so that it could be sent out to the MCU via SPI.\nMAC block used within digital filtering.\nSimulated testbench of digital filtering implementation."
  },
  {
    "objectID": "currentStatus/fpgaToMcu.html",
    "href": "currentStatus/fpgaToMcu.html",
    "title": "FPGA to MCU",
    "section": "",
    "text": "The microcontroller takes in an analog signal from the potentiometer, then converts that value into digital signals using the on-board ADC. The clock speed at which is running at a clock speed of 4 MHz. The MCU then sends the signal to the FPGA using SPI communication."
  },
  {
    "objectID": "currentStatus/fpgaToMcu.html#spi-protocol",
    "href": "currentStatus/fpgaToMcu.html#spi-protocol",
    "title": "FPGA to MCU",
    "section": "",
    "text": "The microcontroller takes in an analog signal from the potentiometer, then converts that value into digital signals using the on-board ADC. The clock speed at which is running at a clock speed of 4 MHz. The MCU then sends the signal to the FPGA using SPI communication."
  },
  {
    "objectID": "currentStatus/fpgaToMcu.html#i2s-protocol-to-pass-audio",
    "href": "currentStatus/fpgaToMcu.html#i2s-protocol-to-pass-audio",
    "title": "FPGA to MCU",
    "section": "I2S Protocol to Pass AUdio",
    "text": "I2S Protocol to Pass AUdio"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ProjectParivo",
    "section": "",
    "text": "Harvey Mudd College supplies a plethora of student DJs that perform regularly around the 5Cs. As two currently aspiring DJs, we wanted to understand the technical workings of audio modifications and create a low-cost, functional deck so that we could perform for our friends. Therefore, this project seeks to build an operational two-channel DJ Mixer that manipulates audio files based on user inputs. Our mixer will be able to control the frequency and gain of audio input through an AUX cord based on physical inputs from the user. The FPGA will apply Finite Impule Response (FIR) digital filtering to the audio, based on user choosen EQ values passed in through the MCU. The audio is then passed into the MCU, where the onboard MCU DAC with Direct Memory Access (DMA) will output the manipulated audio to speakers.\nA demo of our final project is here:"
  },
  {
    "objectID": "index.html#abstract",
    "href": "index.html#abstract",
    "title": "ProjectParivo",
    "section": "",
    "text": "Harvey Mudd College supplies a plethora of student DJs that perform regularly around the 5Cs. As two currently aspiring DJs, we wanted to understand the technical workings of audio modifications and create a low-cost, functional deck so that we could perform for our friends. Therefore, this project seeks to build an operational two-channel DJ Mixer that manipulates audio files based on user inputs. Our mixer will be able to control the frequency and gain of audio input through an AUX cord based on physical inputs from the user. The FPGA will apply Finite Impule Response (FIR) digital filtering to the audio, based on user choosen EQ values passed in through the MCU. The audio is then passed into the MCU, where the onboard MCU DAC with Direct Memory Access (DMA) will output the manipulated audio to speakers.\nA demo of our final project is here:"
  },
  {
    "objectID": "index.html#about-us",
    "href": "index.html#about-us",
    "title": "ProjectParivo",
    "section": "About Us",
    "text": "About Us\nAudrey and Victoria are seniors at Harvey Mudd College, majoring in engineering, and passionate about music. For their E155 (AKA MicroPs) Final Project, they are working together to create a two-channel DJ mixer. Ultimately, they hope to DJ together with their mixer.\n\nVictoria Parizot - Norwalk, CT\nVictoria Parizot is most interested with mechanical and electrical design, and excited to be taking MicroPs this semester! At Harvey Mudd, she is a West Dorm President, a Machine Shop Proctor, and a Member of the Tau Beta Pi Honors Society. In her free time, she enjoys woodworking, taking and developing film photos, and sailing.\nTake a look at her Portfolio to learn more!\n\n\nAudrey Vo - Valley Girl, CA\nAudrey is an APISPAM Head Sponsor, Atwood Dorm President, and Machine Shop Proctor at Harvey Mudd. The past few summers, she has been able to participate in summer research with Prof. Dodds in “Summer Start-Up” and with Prof. Gokli as part of the Riggs Fellowship. She was previously HMC 2025 Class President and also a member of the Prisoner Education Project.\nAudrey is currently a resident of Southern California, and have lived here her entire life. (If you have any recommendations of things to do in CA, please let her know!). In her free time, she love to play pickleball, try new foods, and spend time with friends.\nIf you are interested in learning more about Audrey, please feel free to connect on LinkedIn or explore her portfolio!"
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "ProjectParivo",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nWe would like to thank Professor Brake for his help and guidance throughout the project, especially with his help debugging. We would also like to thank the the E155 Grutors, especially Kavi, for going above and beyond with helping us think about and implement our project and labs. Finally, we would like to thank our classmates, who were always willing to lend a second perspective, even during late nights in the lab."
  },
  {
    "objectID": "currentStatus/digitalFiltering.html",
    "href": "currentStatus/digitalFiltering.html",
    "title": "Digital Filtering",
    "section": "",
    "text": "To apply digital filtering of the output audio signal, we utilize the MCU’s onboard ADC, use SPI to communicate EQ values between the MCU and FPGA, and generate the necessary FIR Coefficients."
  },
  {
    "objectID": "currentStatus/digitalFiltering.html#digital-filtering",
    "href": "currentStatus/digitalFiltering.html#digital-filtering",
    "title": "Digital Filtering",
    "section": "Digital Filtering",
    "text": "Digital Filtering\nWe have set up the onboard MCU ADC to read in the four external potentiometer values and used SPI to transfer these EQ values to the FPGA to be used for digital filtering. We have opted for Finite Impulse Response (FIR) to apply low and high pass filters to the audio data that we will read in from the PCM1808 DAC. The EQ values correspond to 16 buckets between 0 to 20 kHz (the range of human hearing), with each bucket ranging 1.25 kHz (20 kHz/16). Thus, the EQ value influences the passband and stopband of the filters. To implement FIR, we have generated and tested the integer coefficients for the desired filters in Matlab and exported them as a .txt file. The filters will have 128 taps, a number derived from preliminary testing to find the minimum number of taps needed to create the desired filters. The .txt file of coefficients is read into the FPGA using an FSM and similar logic as sbox_sync in lab 7."
  },
  {
    "objectID": "currentStatus/digitalFiltering.html#communicating-eq-values-to-fpga",
    "href": "currentStatus/digitalFiltering.html#communicating-eq-values-to-fpga",
    "title": "Digital Filtering",
    "section": "Communicating EQ Values to FPGA",
    "text": "Communicating EQ Values to FPGA\nThe EQ values are determined by potentiometer voltage dividers being routed into the MCU. The MCU ADC converts these analog values into 8-bit values between 0 to 256, which will ultimately be used to determine the passband frequencies for the low and high pass filters.\nAfter the MCU interprets these voltages into 8-bit values, it passes these values using SPI to the FPGA. Below is an example of a working SPI interaction. When the potentiometer is set to approximately 79.\n\n\n\nEQ Values Printed Out Debug Terminal\n\n\n\n\n\nLogic Analyzer SPI"
  },
  {
    "objectID": "currentStatus/digitalFiltering.html#generating-coefficients",
    "href": "currentStatus/digitalFiltering.html#generating-coefficients",
    "title": "Digital Filtering",
    "section": "Generating Coefficients",
    "text": "Generating Coefficients\nWe opted to pass in FIR coefficients generated in MatLab so that we could utilize the DSP toolbox and easily visualize and adjust the filter and taps.\nIn order to use these coefficients in the FPGA, we wanted to convert the values from floating point to integer, which requires scaling the coefficients by a value of g. The floating point and integer coefficients are shown below, where if we scale the signal we see that the shape of the plots are the same. Thus, when plotting the output signal, it is critical to scale the signal by dividing by g.\nThe below figures are for a lowpass filter with 128 taps and a pass band ending at 1250 hZ.\n\n\n\nInteger coefficients are scaled up from floating point coefficients\n\n\n\n\n\nFloating point and integer coefficients share the same shape\n\n\n\n\n\nFIR Filter as defined by coefficients\n\n\nWe then confirmed the design of these filters by creating a signal with multiple frequency components and applying our filter and gain scaling. To do this, we copied out verilog logic, allowing us to confirm that our logic acted as expected.\n\n\n\nOriginal signal with multiple frequency components\n\n\n\n\n\nOutput and original signal"
  },
  {
    "objectID": "currentStatus/digitalFiltering.html#passing-in-the-coefficients",
    "href": "currentStatus/digitalFiltering.html#passing-in-the-coefficients",
    "title": "Digital Filtering",
    "section": "Passing in the Coefficients",
    "text": "Passing in the Coefficients\nIn order to retrieve the proper coefficients, the filter number was inputted based on a digital input from the MCU. Thus, based on what the user selects, the code will then retrieve the set of 128 coefficients that correspond to the filter value that they requested. This was done by saving a .txt file with all 2048 coefficients (128 coefficients per filter, 16 different filter options), and then storing the desired coefficients synchronously in BRAM. An FSM is used to retrieve all 128 coefficients on each clock cycle that will then be used to digitally filter the signal."
  },
  {
    "objectID": "currentStatus/systemOverview.html",
    "href": "currentStatus/systemOverview.html",
    "title": "System Overview & Documentation",
    "section": "",
    "text": "Harvey Mudd College includes a plethora of student DJs that perform regularly around the 5Cs. As two currently aspiring DJs, we wanted to understand the technical workings of audio modifications and create a functional deck so that we could perform for our friends.\nInsight into how we came up with this project can be found in Victoria’s blog."
  },
  {
    "objectID": "currentStatus/systemOverview.html#motivation",
    "href": "currentStatus/systemOverview.html#motivation",
    "title": "System Overview & Documentation",
    "section": "",
    "text": "Harvey Mudd College includes a plethora of student DJs that perform regularly around the 5Cs. As two currently aspiring DJs, we wanted to understand the technical workings of audio modifications and create a functional deck so that we could perform for our friends.\nInsight into how we came up with this project can be found in Victoria’s blog."
  },
  {
    "objectID": "currentStatus/systemOverview.html#problem-statement",
    "href": "currentStatus/systemOverview.html#problem-statement",
    "title": "System Overview & Documentation",
    "section": "Problem Statement",
    "text": "Problem Statement\nOur overarching goal for this project is to build an operational DJ Mixer that manipulates audio files based on user inputs. Our mixer will be able to control the frequency and gain of two input audio files based on physical inputs from the user."
  },
  {
    "objectID": "currentStatus/systemOverview.html#objectives",
    "href": "currentStatus/systemOverview.html#objectives",
    "title": "System Overview & Documentation",
    "section": "Objectives",
    "text": "Objectives\nThe objectives of this project is below.\n\n\nUse an external ADC to read in a Stereo file into the FPGA\n\n\nCommunicate audio data between the MCU and FPGA\n\n\nImplement low pass and high pass digital filters using the FPGA\n\n\nVary audio volume based on user gain inputs\n\n\nOutput the manipulated audio onto speakers"
  },
  {
    "objectID": "currentStatus/systemOverview.html#system-overview",
    "href": "currentStatus/systemOverview.html#system-overview",
    "title": "System Overview & Documentation",
    "section": "System Overview",
    "text": "System Overview\nThe project is split between the MCU and FPGA. The MCU is in charge of (1) outputing the manipulated audio data with the onboard DAC with DMA, (2) interpreting and transferring the user input EQ values to the FPGA, and (3) acting as the controller for SPI communication. The FPGA acts as (1) the controller to PCM1808 ADC to read in audio and (2) implements digital filters to the data based on EQ values from the MCU. To communicate between the MCU and FPGA we use SPI for both the EQ values and audio data.\nThe system is described in the block diagram and wiring diagram below.\n\n\n\nBlock Diagram for Project PariVo\n\n\n\n\n\nWiring Schematic for Project PariVo"
  },
  {
    "objectID": "currentStatus/systemOverview.html#bill-of-materials",
    "href": "currentStatus/systemOverview.html#bill-of-materials",
    "title": "System Overview & Documentation",
    "section": "Bill of Materials",
    "text": "Bill of Materials\n\n\n\nItem\n\n\nPart Number\n\n\nQuantity\n\n\nCost per\n\n\n\n\nPWM1808 ADC Breakout Board\n\n\nPCM1808\n\n\n1\n\n\n7.99\n\n\n\n\n10k Slide Potentiometer\n\n\nPTA2043-2015CPB103-ND\n\n\n2\n\n\n$1.78\n\n\n\n\nBreadboard-Friendly Stereo Headphone Jack\n\n\nProduct ID: 1699\n\n\n3\n\n\n$0.95\n\n\n\n\nAux Cable\n\n\nSourced from stockroom\n\n\n3\n\n\nn/a"
  },
  {
    "objectID": "currentStatus/inputAudio.html",
    "href": "currentStatus/inputAudio.html",
    "title": "Reading in Audio",
    "section": "",
    "text": "To read in the audio into the FPGA, we need to use an Analog to Digital Converter (ADC) to convert analog stereo audio into digital data that our FPGA can manipulate. We opted to use the PCM1808, a 24-bit stereo ADC with I2S functionality. We will pass in the two different audio channels into the left and right channels, with the FPGA acting as the controller. The wiring diagram between the FPGA and PCM1808 ADC is outlines how the ADC interfaces with our system. Note that MD1, MD0, and FMT are set low with a pull-down resistor to set the PCM1808 as the worker with an I2S 24-bit data format.\n\n\n\nOriginal signal with multiple frequency components\n\n\nI confirm that the audio data is being read with I2S using a logic analyzer. Below are the traces for various audio gains, where D2 connected to DOUT, D4 to BCK, D6 to LRCK, and D7 to SCKI. I set the clock to 12 MHz, therby setting the sampling frequency to be 46.875 kHz, as defined by the SCK. The Left/Right clock is set to 3 MHz, where 24 pulses from bck occur every clock cycle. This is confirmed with the oscilloscope traces. The DOUT shows the digital output of the input audio signal. Since I2S encodes the amplitude into 24-bit values, we would expect lower volumes of music to have smaller 24-bit digital values. This behavior is demonstrated in the following traces, where as we decrease the volume, the MSB is lower and lower.\n\n\n\nDigital output of signal with volume at 0%\n\n\n\n\n\nDigital output of signal with volume at 25%\n\n\n\n\n\nDigital output of signal with volume at 50%\n\n\n\n\n\nDigital output of signal with volume at 100%"
  }
]