[
  {
    "objectID": "currentStatus/dmaToDac.html",
    "href": "currentStatus/dmaToDac.html",
    "title": "Outputting Audio",
    "section": "",
    "text": "To read out the digital audio onto speakers, we will use the onboard MCU DAC with Direct Memory Access (DMA). The DAC has two channels, which we will use to output the two audio signals. We plan to use DMA with a circular buffer to read out the I2S audio data, as this will allow us more flexibility with the timing within the system. Thus, we need to ensure that the input and output rates are equivalent."
  },
  {
    "objectID": "currentStatus/mcuDesign.html",
    "href": "currentStatus/mcuDesign.html",
    "title": "MCU Design",
    "section": "",
    "text": "The microcontroller held three roles in our system. First, it would output the audio, converting it from digital to analog. Second, it would interpret and pass the lowpass and highpass filter cutoff values to the FPGA. Third, it acted as the controller for SPI communication. While we ultimately did not succeed in implementing digital filtering on the FPGA, the MCU fulfilled its role in sending over the filter cutoff values."
  },
  {
    "objectID": "currentStatus/mcuDesign.html#outputting-audio",
    "href": "currentStatus/mcuDesign.html#outputting-audio",
    "title": "MCU Design",
    "section": "Outputting Audio",
    "text": "Outputting Audio\nThe MCU takes in 8-bit mono audio data from the FPGA using SPI and stores the value in memory. As the onboard Digital-to-Analog Converter (DAC) can only read positive voltages, we converted our signed values to unsigned values and stored the value into a variable named leftAudio. We then used the onboard MCU DAC with Direct Memory Access (DMA) to convert the digital data to an analog signal. The DMA transfer was initiated by a reload event of TIM7 and would move the value stored in leftAudio into the output register of the DAC. By setting DMA to circular mode, it would continuously read from the leftAudio variable, as it was updated by SPI. Therefore, it was imperative to ensure that the clock speed of both the FPGA and MCU would be fast enough as to not warp the audio.\nTo make our code scalable to stereo audio, we used both DAC1 and DAC2 and their corresponding DMA channels to output the audio to two separate pins, PA4 and PA5. This also allowed us the flexibility to manipulate the output analog audio with circuits to apply lowpass and highpass filters.\nWhen we opted to use the onboard MCU DAC and SPI, we were hesitant of bringing down the audio data from 24-bit to 8-bit resolution, which would mean lowering the discrete levels of audio from 16,777,215 to 256. While this would not impact the maximum amplitude, it would reduce the precision and dynamic range. We decided the best way to test this would be by doing – so we implemented the DAC and DMA with 8-bit resolution and tried to see if we could spot an audible difference. When testing with sine waves at different frequencies as well as our personal playlists, we could not tell the difference between the original audio versus the MCU output audio. Therefore, we decided that 8-bit audio would be sufficient for this project."
  },
  {
    "objectID": "currentStatus/mcuDesign.html#filter-cutoff-values",
    "href": "currentStatus/mcuDesign.html#filter-cutoff-values",
    "title": "MCU Design",
    "section": "Filter Cutoff Values",
    "text": "Filter Cutoff Values\nThe EQ values are determined by potentiometer voltage dividers being routed into the MCU. The MCU ADC converts these analog values into 8-bit values between 0 to 256, which will ultimately be used to determine the passband frequencies for the low and high pass filters.\nAfter the MCU interprets these voltages into 8-bit values, it passes these values using SPI to the FPGA. Below is an example of a working SPI interaction. When the potentiometer is set to approximately 79.\n\n\n\nEQ Values Printed Out Debug Terminal\n\n\n\n\n\nLogic Analyzer SPI Interaction for EQ Values"
  },
  {
    "objectID": "currentStatus/mcuDesign.html#spi-controller",
    "href": "currentStatus/mcuDesign.html#spi-controller",
    "title": "MCU Design",
    "section": "SPI Controller",
    "text": "SPI Controller\nThe MCU generated the SPI clock and took charge of sending and recieving the potentiometer and audio data packets by using a load and done flag. Where the load flag would be triggered after the MCU has sent the potentionmeter values and the Done flag would be triggered after the FPGA has finished processing an audio packet."
  },
  {
    "objectID": "currentStatus/hardwareDesign.html",
    "href": "currentStatus/hardwareDesign.html",
    "title": "Hardware Design",
    "section": "",
    "text": "Because digital filtering was not implemented on the FPGA, an analog circuit was used instead to control the filtering of the outputted digital audio and the gains of the audio. An RC circuit (low pass filter) was put in series with a CR circuit (high pass filter) to create an overall bandpass filter. The resistors of the RC and CR are 10k potentiometers, while the C value is 1 uF to allow for a cutoff frequency between 15 Hz and 32000 Hz. This is a reasonable range since human hearing goes up to 22000 Hz.\n\n\n\\[ Cutoff Frequency for RC/CR filter = \\frac{1}{2\\pi rc} \\]\n\\[ Potentiometer Range = 5 Hz - 10 kHz \\]\n\\[ f_c = \\frac{1}{2\\pi rc} = \\frac{1}{2\\pi (10000)(1uF)} = 15.92 Hz \\]\n\\[ f_c = \\frac{1}{2\\pi rc} = \\frac{1}{2\\pi (5)(1uF)} = 31,831 Hz \\]\n\n\n\nSchematic of Analog Filters and Gain Control\n\n\nThe output of this bandpass filter was then inputted to another set of sliding 10k potentiometers to control the gain/volume of the audio. An LM386N audio amplifier was then used to connect the output of the gain potentiometers with an 8K speaker because the MCU pins did not generate enough current to drive the speaker."
  },
  {
    "objectID": "currentStatus/hardwareDesign.html#hardware-design",
    "href": "currentStatus/hardwareDesign.html#hardware-design",
    "title": "Hardware Design",
    "section": "",
    "text": "Because digital filtering was not implemented on the FPGA, an analog circuit was used instead to control the filtering of the outputted digital audio and the gains of the audio. An RC circuit (low pass filter) was put in series with a CR circuit (high pass filter) to create an overall bandpass filter. The resistors of the RC and CR are 10k potentiometers, while the C value is 1 uF to allow for a cutoff frequency between 15 Hz and 32000 Hz. This is a reasonable range since human hearing goes up to 22000 Hz.\n\n\n\\[ Cutoff Frequency for RC/CR filter = \\frac{1}{2\\pi rc} \\]\n\\[ Potentiometer Range = 5 Hz - 10 kHz \\]\n\\[ f_c = \\frac{1}{2\\pi rc} = \\frac{1}{2\\pi (10000)(1uF)} = 15.92 Hz \\]\n\\[ f_c = \\frac{1}{2\\pi rc} = \\frac{1}{2\\pi (5)(1uF)} = 31,831 Hz \\]\n\n\n\nSchematic of Analog Filters and Gain Control\n\n\nThe output of this bandpass filter was then inputted to another set of sliding 10k potentiometers to control the gain/volume of the audio. An LM386N audio amplifier was then used to connect the output of the gain potentiometers with an 8K speaker because the MCU pins did not generate enough current to drive the speaker."
  },
  {
    "objectID": "currentStatus/systemOverview.html",
    "href": "currentStatus/systemOverview.html",
    "title": "System Overview & Documentation",
    "section": "",
    "text": "Harvey Mudd College includes a plethora of student DJs that perform regularly around the 5Cs. As two currently aspiring DJs, we wanted to understand the technical workings of audio modifications and create a functional deck so that we could perform for our friends.\nInsight into how we came up with this project can be found in Victoria’s blog."
  },
  {
    "objectID": "currentStatus/systemOverview.html#motivation",
    "href": "currentStatus/systemOverview.html#motivation",
    "title": "System Overview & Documentation",
    "section": "",
    "text": "Harvey Mudd College includes a plethora of student DJs that perform regularly around the 5Cs. As two currently aspiring DJs, we wanted to understand the technical workings of audio modifications and create a functional deck so that we could perform for our friends.\nInsight into how we came up with this project can be found in Victoria’s blog."
  },
  {
    "objectID": "currentStatus/systemOverview.html#problem-statement",
    "href": "currentStatus/systemOverview.html#problem-statement",
    "title": "System Overview & Documentation",
    "section": "Problem Statement",
    "text": "Problem Statement\nOur overarching goal for this project is to build an operational DJ Mixer that manipulates audio files based on user inputs. Our mixer will be able to control the frequency and gain of audio files passed in via an AUX cord based on physical inputs from the user."
  },
  {
    "objectID": "currentStatus/systemOverview.html#objectives",
    "href": "currentStatus/systemOverview.html#objectives",
    "title": "System Overview & Documentation",
    "section": "Objectives",
    "text": "Objectives\nThe objectives of this project are as follows:\n\n\nUse an external ADC to read in a Stereo file into the FPGA\n\n\nCommunicate audio data between the MCU and FPGA\n\n\nImplement low pass and high pass digital filters using the FPGA\n\n\nVary audio volume based on user gain inputs\n\n\nOutput the manipulated audio onto speakers\n\n\nWe met all of these objectives except for digital filtering. While we had digital filtering working in simulation, we ran out of time to implement it in hardware. As a result, we used the potentiometers in RC and CR circuits to implement the lowpass and highpass filters."
  },
  {
    "objectID": "currentStatus/systemOverview.html#system-overview",
    "href": "currentStatus/systemOverview.html#system-overview",
    "title": "System Overview & Documentation",
    "section": "System Overview",
    "text": "System Overview\nThe project is split between the MCU and FPGA. The MCU is in charge of:\n\n\nOutputing the manipulated audio data with the onboard DAC with DMA\n\n\nInterpreting and transferring the user input EQ values to the FPGA\n\n\nActing as the controller for SPI communication\n\n\nThe FPGA handles:\n\n\nGenerating the Clock for the PCM1808 ADC to read in audio\n\n\nDigital filtering of the audio data based on EQ values from the MCU\n\n\nSending audio into the MCU\n\n\nUltimately, filtering was handled with an external circuit on the output of the MCU.\nThe system is described in the block diagram and wiring diagram below.\n\n\n\nFPGA Diagram for Project PariVo\n\n\n\n\n\nWiring Schematic for Project PariVo"
  },
  {
    "objectID": "currentStatus/systemOverview.html#bill-of-materials",
    "href": "currentStatus/systemOverview.html#bill-of-materials",
    "title": "System Overview & Documentation",
    "section": "Bill of Materials",
    "text": "Bill of Materials\nAs our project deals with audio, in addition to the STM32L432KC MCU and UPduino v3.1 with the iCE40 UP5K, we used the following materials. Our new hardware was the PCM1808, an external ADC to convert stereo audio to digital to be read into the FPGA using I2S. More information on the PCM1808 can be found under FPGA & PCM1808 Design.\n\n\n\nItem\n\n\nPart Number\n\n\nQuantity\n\n\nCost per\n\n\n\n\nPCM1808 ADC Breakout Board\n\n\nPCM1808\n\n\n1\n\n\n7.99\n\n\n\n\n10k Slide Potentiometer\n\n\nPTA2043-2015CPB103-ND\n\n\n2\n\n\n$1.78\n\n\n\n\nStereo Headphone Jack\n\n\nID: 1699\n\n\n3\n\n\n$0.95\n\n\n\n\nAux Cable\n\n\nSourced from stockroom\n\n\n3\n\n\nn/a\n\n\n\n\n8Ohm 4W Speakers\n\n\nSourced from stockroom\n\n\n3\n\n\nn/a"
  },
  {
    "objectID": "currentStatus/systemOverview.html#in-progress-photos",
    "href": "currentStatus/systemOverview.html#in-progress-photos",
    "title": "System Overview & Documentation",
    "section": "In-Progress Photos",
    "text": "In-Progress Photos\nHere are some photos of our design process!\n \n\n\n\nDebugging MCU Audio Output"
  },
  {
    "objectID": "currentStatus/digitalFiltering.html",
    "href": "currentStatus/digitalFiltering.html",
    "title": "Digital Filtering",
    "section": "",
    "text": "To apply digital filtering of the output audio signal, we utilize the MCU’s onboard ADC, use SPI to communicate EQ values between the MCU and FPGA, and generate the necessary FIR Coefficients."
  },
  {
    "objectID": "currentStatus/digitalFiltering.html#digital-filtering",
    "href": "currentStatus/digitalFiltering.html#digital-filtering",
    "title": "Digital Filtering",
    "section": "Digital Filtering",
    "text": "Digital Filtering\nWe have set up the onboard MCU ADC to read in the four external potentiometer values and used SPI to transfer these EQ values to the FPGA to be used for digital filtering. We have opted for Finite Impulse Response (FIR) to apply low and high pass filters to the audio data that we will read in from the PCM1808 DAC. The EQ values correspond to 16 buckets between 0 to 20 kHz (the range of human hearing), with each bucket ranging 1.25 kHz (20 kHz/16). Thus, the EQ value influences the passband and stopband of the filters. To implement FIR, we have generated and tested the integer coefficients for the desired filters in Matlab and exported them as a .txt file. The filters will have 128 taps, a number derived from preliminary testing to find the minimum number of taps needed to create the desired filters. The .txt file of coefficients is read into the FPGA using an FSM and similar logic as sbox_sync in lab 7."
  },
  {
    "objectID": "currentStatus/digitalFiltering.html#communicating-eq-values-to-fpga",
    "href": "currentStatus/digitalFiltering.html#communicating-eq-values-to-fpga",
    "title": "Digital Filtering",
    "section": "Communicating EQ Values to FPGA",
    "text": "Communicating EQ Values to FPGA\nThe EQ values are determined by potentiometer voltage dividers being routed into the MCU. The MCU ADC converts these analog values into 8-bit values between 0 to 256, which will ultimately be used to determine the passband frequencies for the low and high pass filters.\nAfter the MCU interprets these voltages into 8-bit values, it passes these values using SPI to the FPGA. Below is an example of a working SPI interaction. When the potentiometer is set to approximately 79.\n\n\n\nEQ Values Printed Out Debug Terminal\n\n\n\n\n\nLogic Analyzer SPI"
  },
  {
    "objectID": "currentStatus/digitalFiltering.html#generating-coefficients",
    "href": "currentStatus/digitalFiltering.html#generating-coefficients",
    "title": "Digital Filtering",
    "section": "Generating Coefficients",
    "text": "Generating Coefficients\nWe opted to pass in FIR coefficients generated in MatLab so that we could utilize the DSP toolbox and easily visualize and adjust the filter and taps.\nIn order to use these coefficients in the FPGA, we wanted to convert the values from floating point to integer, which requires scaling the coefficients by a value of g. The floating point and integer coefficients are shown below, where if we scale the signal we see that the shape of the plots are the same. Thus, when plotting the output signal, it is critical to scale the signal by dividing by g.\nThe below figures are for a lowpass filter with 128 taps and a pass band ending at 1250 hZ.\n\n\n\nInteger coefficients are scaled up from floating point coefficients\n\n\n\n\n\nFloating point and integer coefficients share the same shape\n\n\n\n\n\nFIR Filter as defined by coefficients\n\n\nWe then confirmed the design of these filters by creating a signal with multiple frequency components and applying our filter and gain scaling. To do this, we copied out verilog logic, allowing us to confirm that our logic acted as expected.\n\n\n\nOriginal signal with multiple frequency components\n\n\n\n\n\nOutput and original signal"
  },
  {
    "objectID": "currentStatus/digitalFiltering.html#passing-in-the-coefficients",
    "href": "currentStatus/digitalFiltering.html#passing-in-the-coefficients",
    "title": "Digital Filtering",
    "section": "Passing in the Coefficients",
    "text": "Passing in the Coefficients\nIn order to retrieve the proper coefficients, the filter number was inputted based on a digital input from the MCU. Thus, based on what the user selects, the code will then retrieve the set of 128 coefficients that correspond to the filter value that they requested. This was done by saving a .txt file with all 2048 coefficients (128 coefficients per filter, 16 different filter options), and then storing the desired coefficients synchronously in BRAM. An FSM is used to retrieve all 128 coefficients on each clock cycle that will then be used to digitally filter the signal."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Project Parivo",
    "section": "",
    "text": "Harvey Mudd College supplies a plethora of student DJs that perform regularly around the 5Cs. As two currently aspiring DJs, we wanted to understand the technical workings of audio modifications and create a low-cost, functional deck so that we could perform for our friends. Therefore, this project seeks to build an operational two-channel DJ Mixer that manipulates audio files based on user inputs. Our mixer will be able to control the frequency and gain of audio input through an AUX cord based on physical inputs from the user. The FPGA will apply Finite Impule Response (FIR) digital filtering to the audio, based on user choosen EQ values passed in through the MCU. The audio is then passed into the MCU, where the onboard MCU DAC with Direct Memory Access (DMA) will output the manipulated audio to speakers.\nA demo of our final project is here:"
  },
  {
    "objectID": "index.html#abstract",
    "href": "index.html#abstract",
    "title": "Project Parivo",
    "section": "",
    "text": "Harvey Mudd College supplies a plethora of student DJs that perform regularly around the 5Cs. As two currently aspiring DJs, we wanted to understand the technical workings of audio modifications and create a low-cost, functional deck so that we could perform for our friends. Therefore, this project seeks to build an operational two-channel DJ Mixer that manipulates audio files based on user inputs. Our mixer will be able to control the frequency and gain of audio input through an AUX cord based on physical inputs from the user. The FPGA will apply Finite Impule Response (FIR) digital filtering to the audio, based on user choosen EQ values passed in through the MCU. The audio is then passed into the MCU, where the onboard MCU DAC with Direct Memory Access (DMA) will output the manipulated audio to speakers.\nA demo of our final project is here:"
  },
  {
    "objectID": "index.html#about-us",
    "href": "index.html#about-us",
    "title": "Project Parivo",
    "section": "About Us",
    "text": "About Us\nAudrey and Victoria are seniors at Harvey Mudd College, majoring in engineering, and passionate about music. For their E155 (AKA MicroPs) Final Project, they are working together to create a two-channel DJ mixer. Ultimately, they hope to DJ together with their mixer.\n\nVictoria Parizot - Norwalk, CT\nVictoria Parizot is most interested with mechanical and electrical design, and excited to be taking MicroPs this semester! At Harvey Mudd, she is a West Dorm President, a Machine Shop Proctor, and a Member of the Tau Beta Pi Honors Society. In her free time, she enjoys woodworking, taking and developing film photos, and sailing.\nTake a look at her portfolio to learn more!\n\n\nAudrey Vo - Valley Girl, CA\nAudrey is an APISPAM Head Sponsor, Atwood Dorm President, and Machine Shop Proctor at Harvey Mudd. The past few summers, she has been able to participate in summer research with Prof. Dodds in “Summer Start-Up” and with Prof. Gokli as part of the Riggs Fellowship. She was previously HMC 2025 Class President and also a member of the Prisoner Education Project.\nAudrey is currently a resident of Southern California, and have lived here her entire life. If you have any recommendations of things to do in CA, please let her know! In her free time, she love to play pickleball, try new foods, and spend time with friends.\nIf you are interested in learning more about Audrey, please feel free to connect on LinkedIn or explore her portfolio!"
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Project Parivo",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nWe would like to thank Professor Brake for his help and guidance throughout the project. We would also like to thank the the E155 Grutors, especially Kavi, for going above and beyond with helping us think about and implement our project and labs. We would like to thank Luke for his effortless help in sourcing the materials. Finally, we would like to thank our classmates, who were always willing to lend a second perspective, even during late nights in the lab."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "currentStatus/fpgaToMcu.html",
    "href": "currentStatus/fpgaToMcu.html",
    "title": "FPGA to MCU",
    "section": "",
    "text": "We ended up using mono audio, only sending out the left channel of the stereo data to the MCU for output due to problems with outputting audio. We originally had planned to configure the MCU Serial Audio Interface (SAI) peripheral to I2S. This would allow us to use standard audio interfacing, sending the left and right channel at the same time. While we got close to transmitting, the lack of examples and unclear documentation caused us to pivot to using an external DAC to output audio from the FPGA. We opted to use a UDA1334A I2S DAC. To test this DAC, we used the FPGA to generate clock signals, and hooked it up directly to the ADC for testing. Despite configuring how it requested in the datasheet, we could not get any signals coming out of the DAC. Finally, we opted to resort to SPI between the FPGA and MCU, allowing us to leverage the prexisting SPI transaction for the potentiometer values."
  },
  {
    "objectID": "currentStatus/fpgaToMcu.html#spi-protocol",
    "href": "currentStatus/fpgaToMcu.html#spi-protocol",
    "title": "FPGA to MCU",
    "section": "SPI Protocol",
    "text": "SPI Protocol\nThe MCU and FPGA pass data using SPI protocol, where it passes potentiometer values from the MCU to the FPGA and audio data from the FPGA to the MCU in 8-bit packages. The SPI handshake works with two flags, the Load Flag and the Done Flag. The Load Flag would be raised while the MCU was transmitting EQ values. The Done Flag would be raised once the FPGA was done reading in an audio sample and would be lowered after the FPGA transmitted the audio data to the MCU."
  },
  {
    "objectID": "currentStatus/fpgaDesign.html",
    "href": "currentStatus/fpgaDesign.html",
    "title": "FPGA Design",
    "section": "",
    "text": "The main design features of the FPGA is to receive digital audio from the external ADC, apply digital filters to the audio based on user inputs passed from the MCU, and then send the filtered audio to the MCU. The FPGA receives audio from the ADC using an I2S Communication Protocol, and next implements the onboard multiply-accumulator block (MAC) to the data and then outputs it. Due to time constraints, we were not able to implement digital filtering on our hardware, but we were able to get the desired behavior in ModelSim using the MAC."
  },
  {
    "objectID": "currentStatus/fpgaDesign.html#fpga-design-overview",
    "href": "currentStatus/fpgaDesign.html#fpga-design-overview",
    "title": "FPGA Design",
    "section": "",
    "text": "The main design features of the FPGA is to receive digital audio from the external ADC, apply digital filters to the audio based on user inputs passed from the MCU, and then send the filtered audio to the MCU. The FPGA receives audio from the ADC using an I2S Communication Protocol, and next implements the onboard multiply-accumulator block (MAC) to the data and then outputs it. Due to time constraints, we were not able to implement digital filtering on our hardware, but we were able to get the desired behavior in ModelSim using the MAC."
  },
  {
    "objectID": "currentStatus/fpgaDesign.html#generating-coefficients-for-fir-filters",
    "href": "currentStatus/fpgaDesign.html#generating-coefficients-for-fir-filters",
    "title": "FPGA Design",
    "section": "Generating Coefficients for FIR Filters",
    "text": "Generating Coefficients for FIR Filters\nWe opted to pass in FIR coefficients generated in MatLab so that we could utilize the DSP toolbox and easily visualize and adjust the filter and taps.\nAs a result, our Matlab script would generate the lowpass and highpass filter coefficients for the 16 EQ value buckets. and store these coefficients into a .txt file to be read by the FPGA.\nIn order to use these coefficients in the FPGA, we wanted to convert the values from floating point to integer, which requires scaling the coefficients by a value of g. The floating point and integer coefficients are shown below, where if we scale the signal we see that the shape of the plots are the same. Thus, when plotting the output signal, it is critical to scale the signal by dividing by g. As there would only be 32 g values, we decided that we would hard code these values into the FPGA.\nThe below figures are for a lowpass filter with 128 taps and a pass band ending at 1250 hz.\n\n\n\nInteger coefficients are scaled up from floating point coefficients\n\n\n\n\n\nFloating point and integer coefficients share the same shape\n\n\n\n\n\nFIR Filter as defined by coefficients\n\n\nWe then confirmed the design of these filters by creating a signal with multiple frequency components and applying our filter and gain scaling. To do this, we copied our verilog logic, allowing us to confirm that our logic acted as expected.\n\n\n\nOriginal signal with multiple frequency components\n\n\n\n\n\nOutput vs original signal"
  },
  {
    "objectID": "currentStatus/fpgaDesign.html#passing-in-the-coefficients-to-the-fpga",
    "href": "currentStatus/fpgaDesign.html#passing-in-the-coefficients-to-the-fpga",
    "title": "FPGA Design",
    "section": "Passing in the Coefficients to the FPGA",
    "text": "Passing in the Coefficients to the FPGA\nIn order to retrieve the proper coefficients, the filter number was input based on a digital input from the MCU. Thus, based on what the user selects, the code will then retrieve the set of 128 coefficients that correspond to the filter value that they requested. This was done by saving a .txt file with all 2048 coefficients (128 coefficients per filter, 16 different filter options), and then storing the desired coefficients synchronously in BRAM. An FSM is used to retrieve all 128 coefficients on each clock cycle that will then be used to digitally filter the signal."
  },
  {
    "objectID": "currentStatus/fpgaDesign.html#modeling-dsp",
    "href": "currentStatus/fpgaDesign.html#modeling-dsp",
    "title": "FPGA Design",
    "section": "Modeling DSP",
    "text": "Modeling DSP\nThe modules created in ModelSim contained code from Lab 7 to retrieve the different taps read from a .txt file stored in memory based on desired filter values received from the MCU via SPI. The FPGA would also create a signal window that would contain the past 10 samples of digital audio from the ADC to be used for FIR filtering. This signal window and the retrieved taps would then be input to the MAC to be multiplied and summed up together. The MAC was configured to take in 2 signed 16-bit inputs, and then output a 33-bit result for 10 tap coefficients. It also received the system clock as input generated from the high speed oscillator at 12 MHz. The output data from the MAC was then scaled back down by being divided by the filter’s gains, and then concatenated to 8 bits so that it could be sent out to the MCU via SPI.\n\n\n\nMAC block used within digital filtering\n\n\n\n\n\nSimulated testbench of digital filtering implementation\n\n\nAs shown in the images above, we got DSP to work in simulation, but did not succeed in implementing in hardware."
  },
  {
    "objectID": "currentStatus/fpgaDesign.html#outputting-audio",
    "href": "currentStatus/fpgaDesign.html#outputting-audio",
    "title": "FPGA Design",
    "section": "Outputting Audio",
    "text": "Outputting Audio\nTo output the audio to the MCU, the FPGA would wait for the audio data to be read in from the PCM1808. Once the entire sample was read, the left and right variables would be updated, and the Done flag would be raised. Then, the eq1_core module would pass the updated left channel audio data to the MCU. Once the left audio data was shifted out, the Done flag would be lowered. To learn more about the SPI handshake, see “FPGA and MCU Communication”"
  },
  {
    "objectID": "currentStatus/resultsAndAnalysis.html",
    "href": "currentStatus/resultsAndAnalysis.html",
    "title": "Results & Analysis",
    "section": "",
    "text": "The main consideration when fitting together the different subsystems was timing. We had to keep in mind the ordering of the sampling, the sampling frequency, and the rate of which we input and output audio. Most notably, we had to ensure that timing did not disobey Nyquist’s theorem, which states “that an analog signal can be digitized without aliasing error if and only if the sampling rate is greater than or equal to twice the highest frequency component in a given signal.” Wearable Sensors (Second Edition), 2021\nWe anticipated two types of timing constraints: First, constraints on the sampling rate to ensure that we could support the full range of human hearing and second timing delays between when we input audio versus output audio. We decided that the latter would not impact the usability of our system, as the propagration delay would be too small to hear. As for the first, to capture the full human hearing range of roughly 20 Hz to 20,000 Hz, the sampling rate must be greater than 40 kHz, according to Nyquist’s.\nThe source clock for I2S communication between the PCM1808 and the FPGA was set to 24Mhz. From the PCM1808 datasheet, we know that the system clock (SCKI) runs at \\(256*F_s\\), and that there is an internal clock divider, such that the bit clock (BCK) runs at \\(64*F_s\\) and the left-right clock (LRCK) runs at \\(F_s\\). Therefore, we get that our sampling frequency, \\(F_s\\), is 93.75 kHz, making it so that we can sample frequencies up to 46.875 kHz. We also need to ensure that this sampling rate is preserved throughout so that we are outputting signals at the same rate we are reading them in.\nThe next stage for audio is to be passed to from the FPGA to the MCU for output, which we do with SPI. The SPI source clock (SCK) runs at $master clock / 2^{(BR+1)} $ . Therefore, \\(SCK = 80MHz / 2^{1+1} = 80MHz*4 = 20MHz\\). Each SPI transaction involves sending the 4 potentiometer values, then recieving an audio sample. This requires a handshake between the MCU and FPGA handeled by load and done flags to indicate when each system is ready to output and recieve. Nonetheless, from analysis of the logic analyzer, each SPI communication (including loading and receiving the data) ran faster than 93.75 kHz, making it so that out throughput can be preserved.\nThe final step for audio was for DMA to move audio data to the MCU DAC output register, where it read out on PA4 and PA5. This DMA transfer was triggered by TIM7, which was set to run as fast as possible. Recall that \\(Timer freq = \\frac{clkfreq}{PSC + 1} = \\frac{80 MHz}{10} = 8MHz\\). As we set ARR = 9, then we get that a reload event is triggered every 800kHz. Therefore, the output is faster than the sampling rate of 93.75 kHz. This is suitable for the system, because DMA is set to a circular buffer, meaning that it will continuously output copies of the audio amplitude until it is updated.\nBy designing the system in this way, we allowed ourselves to have flexibility for timing. The constraining factor on output resolution is the input sampling frequency set to 93.75 kHz. Therefore, our system can output frequencies up to 46.875 kHz, which satisfies the range of human hearing."
  },
  {
    "objectID": "currentStatus/inputAudio.html",
    "href": "currentStatus/inputAudio.html",
    "title": "Reading in Audio",
    "section": "",
    "text": "To read in the audio into the FPGA, we need to use an Analog to Digital Converter (ADC) to convert analog stereo audio into digital data that our FPGA can manipulate. We opted to use the PCM1808, a 24-bit stereo ADC with I2S functionality. We will pass in the two different audio channels into the left and right channels, with the FPGA acting as the controller. The wiring diagram between the FPGA and PCM1808 ADC is outlines how the ADC interfaces with our system. Note that MD1, MD0, and FMT are set low with a pull-down resistor to set the PCM1808 as the worker with an I2S 24-bit data format.\n\n\n\nOriginal signal with multiple frequency components\n\n\nI confirm that the audio data is being read with I2S using a logic analyzer. Below are the traces for various audio gains, where D2 connected to DOUT, D4 to BCK, D6 to LRCK, and D7 to SCKI. I set the clock to 12 MHz, therby setting the sampling frequency to be 46.875 kHz, as defined by the SCK. The Left/Right clock is set to 3 MHz, where 24 pulses from bck occur every clock cycle. This is confirmed with the oscilloscope traces. The DOUT shows the digital output of the input audio signal. Since I2S encodes the amplitude into 24-bit values, we would expect lower volumes of music to have smaller 24-bit digital values. This behavior is demonstrated in the following traces, where as we decrease the volume, the MSB is lower and lower.\n\n\n\nDigital output of signal with volume at 0%\n\n\n\n\n\nDigital output of signal with volume at 25%\n\n\n\n\n\nDigital output of signal with volume at 50%\n\n\n\n\n\nDigital output of signal with volume at 100%"
  }
]